/*  cdma-simple.c - The simplest kernel module.

* Copyright (C) 2013 - 2016 Xilinx, Inc
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

#include <linux/delay.h>
#include <linux/dmaengine.h>
#include <linux/dma-mapping.h>

#include <linux/of_dma.h>
#include <linux/platform_device.h>
#include <linux/wait.h>
/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR ("Xilinx Inc.");
MODULE_DESCRIPTION ("cdma-simple - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "cdma-simple"

/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
unsigned myint = 0xdeadbeef;
char *mystr = "default";
static unsigned int test_buf_size = 64;
struct dma_chan *g_chan;

module_param(test_buf_size, uint, S_IRUGO);
MODULE_PARM_DESC(test_buf_size, "Size of the memcpy test buffer");

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);

static void cdmatest_callback(void *completion)
{
	complete(completion);
}

static int cdmatest_func(struct dma_chan *chan)
{
	int ret;
	int i;
	int src_cnt, dst_cnt;
	u8 **srcs, **dsts;
	struct dma_device *dev = chan->device;
	struct dma_async_tx_descriptor *tx = NULL;
	dma_addr_t dma_srcs[src_cnt];
	dma_addr_t dma_dsts[dst_cnt];
	dma_cookie_t cookie;
	struct completion cmp;
	unsigned long tmo;
	u8 align=0;
	unsigned int len, src_off, dst_off;
	enum dma_status status;
	enum dma_ctrl_flags flags;
	int cnt=0;
	u8 *tmp;
	void* bram = 0xf0000000;
	
	ret = -ENOMEM;

	src_cnt=dst_cnt=1;

	printk(KERN_INFO "test_buf_size : %d\n",test_buf_size);

	dsts = kcalloc(dst_cnt+1, sizeof(u8 *), GFP_KERNEL);
	if(!dsts){
		pr_err("DSTS memory allocation fail....\n");
	}
	for(i=0; i<dst_cnt; i++){
		dsts[i] = kmalloc(test_buf_size, GFP_KERNEL);
		printk(KERN_INFO "dsts[%d]:%x\n",i, dsts[i]);
		if(!dsts[i]){
			pr_err("DSTS[%d] memory allocation fail....\n", i);
		}
	}
	dsts[i]=NULL;

	if(1 << align > test_buf_size){
		pr_err("%u-byte buffer too small for %d-byte alignment\n", test_buf_size, 1 << align);
		return -1;
	}

	len = test_buf_size;
	printk(KERN_INFO "len : %d\n",len);

	flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;

	for(i=0; i<dst_cnt; i++){
		dma_dsts[i] = dma_map_single(dev->dev, dsts[i], len, DMA_MEM_TO_MEM);
	}

	tx = dev->device_prep_dma_memcpy(chan, dma_dsts[0], bram, len, flags);
	if(!tx){
		pr_err("device_prep_dma_memcpy err\n");
		return -1;
	}

	tmo = msecs_to_jiffies(3000);

	init_completion(&cmp);
	tx->callback = cdmatest_callback;
	tx->callback_param = &cmp;
	cookie = tx->tx_submit(tx);

	if(dma_submit_error(cookie)){
		pr_err("Failed to do DMA tx_submit\n");
	}
/*	
	printk(KERN_INFO "\n###################################################\n");
	printk(KERN_INFO "Write data to address 0xa0001000 using peekpoke app.\n");
	printk(KERN_INFO "example > # poke 0xa0001000 1024\n");
	printk(KERN_INFO "####################################################\n");
	ssleep(5);
*/
	dma_async_issue_pending(chan);

	tmo = wait_for_completion_timeout(&cmp, tmo);
	status = dma_async_is_tx_complete(chan, cookie, NULL, NULL);

	if(tmo == 0){
		pr_err("TIME OUT\n");
	}else if(status != DMA_COMPLETE){
		pr_err("NOT COMPLETE\n");
	}else{
		for(i=0; i<dst_cnt; i++)
			dma_unmap_single(dev->dev, dma_dsts[i], len, DMA_MEM_TO_MEM);

		printk(KERN_INFO "\n RESULT\n");
		tmp = dsts[0];
		for(i=0; i<len; ){
			printk(KERN_INFO "|%02x|%02x|%02x|%02x|-|%02x|%02x|%02x|%02x|\n",*(tmp+i), *(tmp+i+1), *(tmp+i+2), *(tmp+i+3), *(tmp+i+4), *(tmp+i+5), *(tmp+i+6), *(tmp+i+7));
			i=i+8;
		}
	}
	ret = 0;

	for(i=0; i<dst_cnt; i++)
		kfree(dsts[i]);
	kfree(dsts);
	
	return ret;
}

static int cdma_simple_probe(struct platform_device *pdev)
{
	struct dma_chan *chan;
	int err;

	chan = dma_request_slave_channel(&pdev->dev, "cdma");
	if (IS_ERR(chan)) {
		pr_err("xilinx_cdmatest: No channel\n");
		return PTR_ERR(chan);
	}
	g_chan = chan;
	err = cdmatest_func(chan);
	if (err) {
		pr_err("xilinx_cdmatest: Unable to add channel\n");
		goto free_tx;
	}   
	return 0;

free_tx:
	dma_release_channel(chan);

return err;
}

static int cdma_simple_remove(struct platform_device *pdev)
{
	dma_release_channel(g_chan);
	return 0;
}

static struct of_device_id cdma_simple_of_match[] = {
	{ .compatible = "xilinx,cdma-driver", },
	{ /* end of list */ },
};

static struct platform_driver cdma_simple_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= cdma_simple_of_match,
	},
	.probe		= cdma_simple_probe,
	.remove		= cdma_simple_remove,
};

static int __init cdma_simple_init(void)
{
	printk("<1>Hello module world.\n");
	printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,mystr);

	return platform_driver_register(&cdma_simple_driver);
}


static void __exit cdma_simple_exit(void)
{
	platform_driver_unregister(&cdma_simple_driver);
	printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(cdma_simple_init);
module_exit(cdma_simple_exit);
